require 'rexml/document'

# KEGG class is designed to build ppi networks based on KEGG pathways.
#
# = Example Usage
# To get only one pathway, using class method is better than creating
# a KEGG object.
#   # bad
#   BioTCM::Databases::KEGG.new("05010") # => KEGG object
#   # good
#   BioTCM::Databases::KEGG.get_pathway("hsa05010") # => Pathway object
#
# Load a list of pathways in one KEGG object
#   pathway_list = ["hsa00010", "hsa00020"]
#   BioTCM::Databases::KEGG.new(pathway_list)
#
# Load all pathways of hsa and merge into one huge network
#   BioTCM::Databases::KEGG.new(nil, 'hsa').merge.network
#   # => [ [gene1 ,gene2], ...]
#
# = About KEGG
# KEGG is a database resource for understanding high-level functions and
# utilities of the biological system, such as the cell, the organism and the
# ecosystem, from molecular-level information, especially large-scale
# molecular datasets generated by genome sequencing and other high-throughput
# experimental technologies.
#
# = Reference
# 1. {http://www.genome.jp/kegg/ KEGG website}
# 2. {http://www.ncbi.nlm.nih.gov/pubmed/22080510 Kanehisa, M., Goto, S., Sato, Y., Furumichi, M., and Tanabe, M.; KEGG for integration and interpretation of large-scale molecular datasets. Nucleic Acids Res. 40, D109-D114 (2012).}
# 3. {http://www.ncbi.nlm.nih.gov/pubmed/10592173 Kanehisa, M. and Goto, S.; KEGG: Kyoto Encyclopedia of Genes and Genomes. Nucleic Acids Res. 28, 27-30 (2000).}
class BioTCM::Databases::KEGG
  # Struct for storing pathway information
  # @attr id [String] KEGG pathway id
  # @attr genes [Array] An *Entrez* *ID* list of genes
  # @attr network [Array] A list of edges between genes
  # @attr associated_pathways [Array] A list of KEGG pathway ids
  Pathway = Struct.new(:id, :genes, :network, :associated_pathways) do
    def inspect
      "#<BioTCM::Databases::KEGG::Pathway @id=#{id.inspect}>"
    end

    def to_s
      inspect
    end
  end

  # Current version of KEGG
  VERSION = '0.1.0'.freeze
  # KEGG default organism: Homo sapiens
  DEFAULT_ORGANISM = 'hsa'.freeze
  # KEGG identifer patterns
  PATTERNS = {
    organism: /^[a-z]{3,4}$/,
    pathway: {
      official: /^[a-z]{3,4}\d{5}$/,
      alternative: /^\d{5}$/
    }
  }.freeze
  # Downloading url
  URLS = {
    pathway_kgml: ->(pathway_id) { "http://rest.kegg.jp/get/#{pathway_id}/kgml" },
    pathway_list: ->(organism) { "http://rest.kegg.jp/list/pathway/#{organism}" }
  }.freeze

  # Get the pathways
  # @return [Hash] Pathway ids as keys
  attr_reader :pathways

  # Validate the pathway_id
  # @param pathway_id [String]
  # @param organism [String]
  # @return [String] Valid pathway ID, nil returned if unable to validate)
  # @raise ArgumentError Raised if organism invalid
  def self.validate_pathway_id(pathway_id, organism = DEFAULT_ORGANISM)
    raise ArgumentError, 'Invalid organism' unless organism =~ PATTERNS[:organism]
    case pathway_id
    when PATTERNS[:pathway][:official]    then pathway_id
    when PATTERNS[:pathway][:alternative] then organism + pathway_id
    else return nil
    end
  end

  # Check if pathway_id is a valid KEGG pathway id
  # @return [Boolean]
  def self.valid_pathway_id?(pathway_id)
    return true if pathway_id =~ PATTERNS[:pathway][:official]
    return true if pathway_id =~ PATTERNS[:pathway][:alternative]
    false
  end

  # Get the list of all pathways of given organism
  # @param organism [String]
  # @return [Array]
  # @raise ArgumentError
  def self.get_pathway_list(organism = DEFAULT_ORGANISM)
    raise ArgumentError, 'Invalid organism' unless organism =~ PATTERNS[:organism]
    file_path = BioTCM.path_to("kegg/list_#{organism}.txt")
    unless File.exist?(file_path)
      fout = File.open(file_path, 'w')
      fout.puts BioTCM.curl(URLS[:pathway_list].call(organism))
      fout.close
    end
    list = []
    # Yield the pattern of pathway ids
    /\^(.+)\$/ =~ PATTERNS[:pathway][:alternative].inspect
    pattern = Regexp.new("^path:(#{organism}" + Regexp.last_match[1] + ')')
    File.open(file_path).each { |line| list << Regexp.last_match[1] if line.match(pattern) }
    list
  end

  # Get the pathway specified by pathway_id
  # @param pathway_id [String] KEGG pathway id (using {DEFAULT_ORGANISM} if not specified)
  # @return [Pathway]
  # @raise RuntimeError if pathway_id not exist
  def self.get_pathway(pathway_id)
    raise ArgumentError, 'Invalid pathway_id' unless (pathway_id = validate_pathway_id(pathway_id))

    file_path = BioTCM.path_to("kegg/#{pathway_id}.xml")
    unless File.exist?(file_path)
      BioTCM.logger.info('KEGG') { "Downloading the KGML of pathway #{pathway_id.inspect} from KEGG" }
      content = BioTCM.curl(URLS[:pathway_kgml].call(pathway_id))
      fout = File.open(file_path, 'w')
      fout.puts(content)
      fout.close
    end
    doc = REXML::Document.new(File.open(file_path).readlines.join)
    pathway = Pathway.new(pathway_id, [], [], [])

    # Get entry list
    entry_list = {}
    doc.elements.each('pathway/entry') do |entry|
      entry_id = entry.attributes['id']
      case entry.attributes['type']
      when 'gene'
        entry_list[entry_id] = { type: :gene, genes: [] }
        entry.attributes['name'].scan(/hsa:(\d+)/) { |match| entry_list[entry_id][:genes] << match[0] }
      when 'group'
        entry_list[entry_id] = { type: :group, components: [], genes: [] }
        entry.elements.each('component') do |component|
          entry_list[entry_id][:components] << component.attributes['id']
        end
      when 'map'
        entry_list[entry_id] = { type: :map, genes: [] }
        /path:(?<map>\w+)/ =~ entry.attributes['name']
        entry_list[entry_id][:map] = map
        pathway.associated_pathways << map
      end
    end
    # Build pathway.genes & process group entry
    entry_list.each_value do |hash|
      case hash[:type]
      when :gene
        hash[:genes].each { |gene| pathway.genes << gene }
      when :group
        # Link genes between entries
        hash[:components].combination(2).each do |comb|
          entry_list[comb[0]][:genes].each do |gene0|
            entry_list[comb[1]][:genes].each do |gene1|
              pathway.network << [gene0, gene1] << [gene1, gene0]
            end
          end
        end
        # Build gene list for the group
        hash[:components].each { |entry_id| hash[:genes] += entry_list[entry_id][:genes] }
        hash[:genes].uniq!
      end
    end
    # Get entry relation list
    entry_relation_list = []
    doc.elements.each('pathway/relation') do |relation|
      next unless entry_list.key?(relation.attributes['entry1'])
      next unless entry_list.key?(relation.attributes['entry2'])

      # One-direction or two-direction
      relation.elements.each('subtype') do |subtype|
        case subtype.attributes['value']
        when '-->', '--|', '..>', '+p', '-p', '+g', '+u', '+m'
          entry_relation_list << [relation.attributes['entry1'], relation.attributes['entry2']]
          break
        when '...', '---'
          entry_relation_list << [relation.attributes['entry1'], relation.attributes['entry2']]
          entry_relation_list << [relation.attributes['entry2'], relation.attributes['entry1']]
          break
        end
      end
    end
    # Load relation into :network
    entry_relation_list.each do |pair|
      entry_list[pair[0]][:genes].each do |gene1|
        entry_list[pair[1]][:genes].each do |gene2|
          pathway.network.push [gene1, gene2]
        end
      end
    end
    pathway.genes.uniq!
    pathway.network.uniq!
    pathway
  end

  # Create a new KEGG object
  # @overload initialize(pathway_id, organism = DEFAULT_ORGANISM)
  #   Load the pathway specified by pathway_id
  #   @param pathway_id [String] KEGG pathway ID
  #   @param organism [String] Default organism for unspecific pathway number
  # @overload initialize(pathway_ids, organism = DEFAULT_ORGANISM)
  #   Load pathways specified by pathway_ids
  #   @param pathway_ids [Array] KEGG pathway IDs
  #   @param organism [String] Default organism for unspecific pathway number
  # @overload initialize(nil, organism = DEFAULT_ORGANISM)
  #   Load all pathways of the specified organism
  #   @param [nil]
  #   @param organism [String] Default organism for unspecific pathway number
  def initialize(pathway_id = nil, organism = DEFAULT_ORGANISM)
    if pathway_id
      pathway_ids = []
      (pathway_id.respond_to?(:each) ? pathway_id : [pathway_id]).each do |id|
        valid_id = self.class.validate_pathway_id(id, organism)
        if valid_id
          pathway_ids << valid_id
        else
          BioTCM.logger.warn('KEGG') { "Discard invalid pathway id #{id.inspect}" }
        end
      end
    else
      pathway_ids = self.class.get_pathway_list(organism)
    end

    BioTCM.logger.debug('KEGG') { "Start to load pathways: #{pathway_ids.inspect}" }
    @pathways = {}
    pathway_ids.each { |id| @pathways[id] = self.class.get_pathway(id) }
  end

  # Extend to associated pathways
  # @return [self]
  def extend_to_associated
    pathway_ids = []
    @pathways.each_value { |pathway| pathway_ids |= pathway.associated_pathways }
    (pathway_ids - @pathways.keys).each { |id| @pathways[id] = self.class.get_pathway(id) }
    self
  end

  # Merge pathways into one
  # @return [Pathway]
  def merge
    merged = Pathway.new(:merged, [], [], [])
    BioTCM.logger.info('KEGG') { "Generating the merged network for #{inspect}" }
    @pathways.each_value do |pathway|
      merged.genes |= pathway.genes
      merged.network |= pathway.network
    end
    merged
  end

  # @private
  def inspect
    "#<BioTCM::Databases::KEGG pathways.keys=#{@pathways.keys.inspect}>"
  end

  # @private
  def to_s
    inspect
  end
end
